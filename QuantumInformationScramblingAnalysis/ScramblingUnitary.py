"""
File name: 
    ScramblingUnitary.py
Author: 
    J. Abraham Hernández
Programme function: 
    Generate and characterize a many-body unitary
    This unitary is composed of k-cycles, in which a single qubit gate followed by an entangling XX gate
    A random string characterized by BDM determines the exact structure of a cycle (hint: qiskit_rng doesn't seem to work properly! QuantumCoinFlip() provides an alternative)
"""

from math import pi
from numpy.core.defchararray import startswith
from qiskit import *
from pybdm import BDM
from qiskit.quantum_info.operators.operator import Operator
import numpy as np
import timeit

# Quantum coin flip to determine random bit string 
# SLOW quantum implementation, not better than just simple random numpy arrays
""" def QuantumCoinFlip(flips):
    # Simulates a perfect coin
    q = QuantumRegister(1)
    c = ClassicalRegister(1)
    perfect_coin = QuantumCircuit(q,c)
    perfect_coin.h(q[0])
    perfect_coin.measure(q,c)
    M_simulator = Aer.backends(name="qasm_simulator")[0]
    M = execute(perfect_coin, M_simulator, shots=flips, meas_return="single").result().get_counts(perfect_coin)
    return M """

def QuantumCoinFlip(flips):
    M = np.random.randint(2, size=flips)
    return M

# Generation of n*(6*k) entry matrix - random string which indicate which gate is performed
def RandomStrings(n, k):
    gen_strings = []
    single_string = []
    for i in range(n):
        for j in range(k*6):    # every cycle contains 6 random cbits
            if QuantumCoinFlip(1)[0]!=0:
            # if QuantumCoinFlip(1).get("0")!=None:
                single_string.append(1)
            else:
                single_string.append(0)
        if len(gen_strings)==0:
            gen_strings = single_string
        else: 
            gen_strings = np.vstack((gen_strings, single_string))
        single_string = np.array(single_string)
        single_string = []
    return gen_strings

# Initialization of Block Decomposition Method option - characterizes randomness of a binary-entry matrix
bdm = BDM(ndim=2, nsymbols=2)

# Integer to gate dict - 4-7 belong to axes of rotation 45° from the main X-Y axes
NumberToGateDict = {
    0 : "ScramblingCircuit.rx(pi/2, i)",
    1 : "ScramblingCircuit.rx((-1)*pi/2, i)",
    2 : "ScramblingCircuit.ry(pi/2, i)",
    3 : "ScramblingCircuit.ry((-1)*pi/2, i)",
    4 : "ScramblingCircuit.r(pi/2, pi/4, i)",
    5 : "ScramblingCircuit.r((-1)*pi/2, pi/4, i)",
    6 : "ScramblingCircuit.r(pi/2, 3*(pi/4), i)",
    7 : "ScramblingCircuit.r((-1)*pi/2, 3*(pi/4), i)"
} 

# Main function, scrambling unitary
def ScramblingU(n, k, nearest=True, filters=True, printArray=False):
    """Return the resulting SU as generated by random binary array
    Args:
        n (int): number of qubits
        k (int): number of cycles within SU
        nearest (bool): True if nearest-neighbor interaction is present, else all-to-all connectivity is assumed resulting in far-reaching entangling gates
        filters (bool): True if a cycle is allowed to not include a gate 
    Returns: 
        Operator object containing the ScramblingU
        BDM Score of the current ScramblingU
    Additional info:
        The structure of a cycle in the SU for a single qubit is defined by either a 6 random bit string, e.g. 100101, a description follows
            The first two bits define whether or not single (or entangling) gates are applied; in the example, SQ-gate is applied, EG are not.
            Single qubit gates are attached to a number in base 10, the next 4-bits in the string decide which specific gate is applied
            The next bit defines if the entangling gate is done with the qubit preceding (0) or succeeding (1) the qubit.
    """
    # Initialize rule array and characterize it via BDM
    BitRules = RandomStrings(n, k)
    if filters!=True:
        for i in range(k):
            BitRules[:, i*6] = 1
            BitRules[:, i*6+4] = 1
    # global BDMScore
    BDMScore = bdm.nbdm(BitRules)
    if printArray!=False:
        print("Rule array: " + "\n{v1}\n".format(v1=BitRules) + "BDM Score: " + "\t{v2}\n".format(v2=BDMScore))

    # Initializing and filling the SC
    ScramblingRegister = QuantumRegister(n,"q")
    ScramblingCircuit = QuantumCircuit(ScramblingRegister)

    # Repeat gate application for k-cycles
    for j in range(k): 
        # Single qubit gates
        for i in range(n): 
            if BitRules[:, j*6][i]==1:
                y = int("".join([str(char) for char in BitRules[i, 6*j+1:6*j+4]]), 2)
                # apply gate in y to the i-th qubit: using dictionary
                # print(NumberToGateDict[y])
                eval(NumberToGateDict[y])
            else:
                # print("perform identity")
                ScramblingCircuit.id(i)
        # Entangling gates 
        for i in range(n): 
            if BitRules[:, j*6+4][i]==1: 
                # If only nearest-neighbor interactions are on
                if nearest:
                    if i < n-1:
                        ScramblingCircuit.iswap(i,i+1)
                        # ScramblingCircuit.rxx(pi/2, i,i+1)
                    else:
                        ScramblingCircuit.iswap(i,i-1)
                        # ScramblingCircuit.rxx(pi/2, i, i-1)
                else:
                    tq_cq = np.random.randint(n,size=(2,1))
                    while tq_cq[[0]]==tq_cq[[1]]:
                        tq_cq = np.random.randint(n,size=(2,1))
                    ScramblingCircuit.iswap(int(tq_cq[[0]]),int(tq_cq[[1]]))
                    # ScramblingCircuit.rxx(pi/2, int(tq_cq[[0]]), int(tq_cq[[1]]))
        ScramblingCircuit.barrier()
    # ScrUnitary = ScramblingCircuit.to_instruction()
    ScrUnitary = Operator(ScramblingCircuit.to_instruction())
    return ScrUnitary, BDMScore

# To take the adjoint of a unitary operator it suffices to invert its matrix representation
# Adjoint of the scrambling unitary
def Udagger(inOp):
    """Return the adjoint/inverse of a unitary operator
    Args:
        u (Operator): unitary to be inverted
    Returns: 
        Operator object 
    Additional info:
        For unitary operators U^dagger = U^-1
    """
    # Check if indeed the supplied operator is unitary
    # inOp = Operator(u)
    if inOp.is_unitary():
        daggMat = np.linalg.inv(inOp.data)
        daggOp = Operator(daggMat)
    else:
        print("Inputted operator isn't unitary!")
    return daggOp


if __name__ == "__main__":

    # ---Example implementation---

    # - Timer starts - 
    t_0 = timeit.default_timer()

    # Random scrambling unitary and BDM score
    # Operator definition
    scrOp, bdmscore = ScramblingU(5,2, nearest=False, filters=False, printArray=False)
    udagg=Udagger(scrOp)
    
    # Verification to see if both operators are indeed unitary
    # print("Unitarity tests: \nU\t-\t{v1}\nUdagg\t-\t{v2}".format(v1=scrOp.is_unitary(), v2=udagg.is_unitary()))
    
    # Circuit and register
    qr1 = QuantumRegister(5, 'q')
    circ1 = QuantumCircuit(qr1)

    # U some x gates and then Udagg; for example
    circ1.append(scrOp, [qr1[i] for i in range(5)])
    circ1.x([qr1[i] for i in range(3)])
    circ1.append(udagg, [qr1[i] for i in range(5)])
    
    print("A part of the circuit used to determine the time dependence of the OTOC is as follows:\n")
    # Print circuits or decomposed version as individual gate instructions
    print(circ1)
    print("We're effectively computing UOU^dagger, which is the time evolution under the scrambling unitary in the Heisenberg picture.\n")

    print("Each randomly generated unitary has a distinct tag which allows us to distinguish it from the rest, that tag comes in form of its BDM score.\n")
    # Randomness measure
    print("BDM for SU: {v1}\n".format(v1=bdmscore))

    # - Time checkpoint - 
    t_1 = timeit.default_timer() - t_0
    print("Exec time: {}sec".format(t_1))