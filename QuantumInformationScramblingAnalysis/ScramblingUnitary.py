"""
File name: 
    ScramblingUnitary.py
Author: 
    J. Abraham Hernández
Programme function: 
    Generate and characterize a many-body unitary
    This unitary is composed of k-cycles, in which a single qubit gate followed by an entangling XX gate
    A random string characterized by BDM determines the exact structure of a cycle (hint: qiskit_rng doesn't seem to work properly! QuantumCoinFlip() provides an alternative)
"""

from math import pi
from numpy.lib.scimath import sqrt
from numpy.random import default_rng
from qiskit import *
from qiskit.circuit import gate, parameter
import numpy as np
from pybdm import BDM
from qiskit.circuit.bit import Bit
from qiskit.quantum_info.operators.operator import Operator

# Quantum coin flip to determine random bit string 
# TODO: see if QCF is "more random" than simple random array generation - it certainly isn't faster!
def QuantumCoinFlip(flips):
    # Simulates a perfect coin
    q = QuantumRegister(1)
    c = ClassicalRegister(1)
    perfect_coin = QuantumCircuit(q,c)
    perfect_coin.h(q[0])
    perfect_coin.measure(q,c)
    M_simulator = Aer.backends(name="qasm_simulator")[0]
    M = execute(perfect_coin, M_simulator, shots=flips, meas_return="single").result().get_counts(perfect_coin)
    return M

# Generation of n*(6*k) entry matrix - random string which indicate which gate is performed
def RandomStrings(n, k):
    gen_strings = []
    single_string = []
    for i in range(n):
        for j in range(k*6):    # every cycle contains 6 random cbits
            if QuantumCoinFlip(1).get("0")!=None:
                single_string.append(1)
            else:
                single_string.append(0)
        if len(gen_strings)==0:
            gen_strings = single_string
        else: 
            gen_strings = np.vstack((gen_strings, single_string))
        single_string = np.array(single_string)
        single_string = []
    return gen_strings

# Initialization of Block Decomposition Method option - characterizes randomness of a binary-entry matrix
bdm = BDM(ndim=2, nsymbols=2)

# Integer to gate dict - 4-7 belong to axes of rotation 45° from the main X-Y axes
NumberToGateDict = {
    0 : "ScramblingCircuit.rx(pi/2, i)",
    1 : "ScramblingCircuit.rx((-1)*pi/2, i)",
    2 : "ScramblingCircuit.ry(pi/2, i)",
    3 : "ScramblingCircuit.ry((-1)*pi/2, i)",
    4 : "ScramblingCircuit.r(pi/2, pi/4, i)",
    5 : "ScramblingCircuit.r((-1)*pi/2, pi/4, i)",
    6 : "ScramblingCircuit.r(pi/2, 3*(pi/4), i)",
    7 : "ScramblingCircuit.r((-1)*pi/2, 3*(pi/4), i)"
} 

# Main function, scrambling unitary
def ScramblingUnitary(n, k, dagger=False, nearest=True, filters=True, printArray=False):
    """Return the resulting SU as generated by maximal BDM array
    Args:
        n (int): number of qubits
        k (int): number of cycles within SU
        nearest (bool): True if nearest-neighbor interaction is present, else all-to-all connectivity is assumed resulting in far-reaching entangling gates
        filters (bool): True if a cycle is allowed to not include a gate 
    Returns: 
        Instruction object containing the ScrUnitary
        BDM Score of the current ScrUnitary
    Additional info:
        The structure of a cycle in the SU for a single qubit is defined by either a 6 random bit string, e.g. 100101, a description follows
            The first two bits define whether or not single (or entangling) gates are applied; in the example, SQ-gate is applied, EG are not.
            Single qubit gates are attached to a number in base 10, the next 4-bits in the string decide which specific gate is applied
            The next bit defines if the entangling gate is done with the qubit preceding (0) or succeeding (1) the qubit.
    """
    # Initialize rule array and characterize it via BDM
    BitRules = RandomStrings(n, k)
    if filters!=True:
        for i in range(k):
            BitRules[:, i*6] = 1
            BitRules[:, i*6+4] = 1
    # global BDMScore
    BDMScore = bdm.nbdm(BitRules)
    if printArray!=False:
        print("Rule array: " + "\n{v1}\n".format(v1=BitRules) + "BDM Score: " + "\t{v2}\n".format(v2=BDMScore))

    # Initializing and filling the SC
    ScramblingRegister = QuantumRegister(n,"q")
    ScramblingCircuit = QuantumCircuit(ScramblingRegister)

    # Non-quantum random stuffs
    # rng = default_rng(765)
    # rtargets = rng.integers(low=0, high=n, size=1)

    # Repeat gate application for k-cycles
    for j in range(k): 
        # Single qubit gates
        for i in range(n): 
            if BitRules[:, j*6][i]==1:
                y = int("".join([str(char) for char in BitRules[i, 6*j+1:6*j+4]]), 2)
                # apply gate in y to the i-th qubit: using dictionary
                # print(NumberToGateDict[y])
                eval(NumberToGateDict[y])
                # If SU^dagger is called
                if dagger:
                    pindex = NumberToGateDict[y].find("p")
                    reg = NumberToGateDict[y]
                    hermitian = reg[:pindex]+"(-1)*"+reg[pindex:]
                    eval(hermitian)
            else:
                # print("perform identity")
                ScramblingCircuit.id(i)
        # Entangling gates 
        for i in range(n): 
            if BitRules[:, j*6+4][i]==1: 
                # If only nearest-neighbor interactions are on
                if nearest:
                    if i < n-1:
                        ScramblingCircuit.rxx(pi/2, i,i+1)
                        if dagger:
                            ScramblingCircuit.rxx(-pi/2, i,i+1)
                    else:
                        ScramblingCircuit.rxx(pi/2, i, i-1)
                        if dagger:
                            ScramblingCircuit.rxx(-pi/2, i, i-1)
                else:
                    # TODO: find a better way to implement chaotic SYK model - more "controlled"
                    if dagger:
                        ScramblingCircuit.rxx(-pi/2, i, i-1)
                    ScramblingCircuit.rxx(pi/2, i, i-1)
        ScramblingCircuit.barrier()
    ScrUnitary = ScramblingCircuit.to_instruction()
    return ScrUnitary, BDMScore

if __name__ == "__main__":
#     print("Running ScramblingUnitary.py directly")
# else:
#     print("Running ScramblingUnitary.py as import")
    
    # ---Minimal implementation---
    # Random scrambling unitary and BDM score
    # NOTE: scrgate is of type Instruction, it can be then via Operator(*) be converted to a matrix-represented operator within qiskit
    scrgate, bdmscore = ScramblingUnitary(5,2, dagger=False, nearest=False, filters=True, printArray=False)
    # print((-1)*(-1)*pi)

    # print(len(NumberToGateDict))
    # for i in range(len(NumberToGateDict)):
    #     pindex = NumberToGateDict[i].find("p")
    #     reg = NumberToGateDict[i]
    #     hermitian = reg[:pindex]+"(-1)*"+reg[pindex:]
    #     print(hermitian, pindex)


    
    
    qr = QuantumRegister(5, 'q')
    circ = QuantumCircuit(qr)
    circ.append(scrgate, [qr[0],qr[1],qr[2],qr[3],qr[4]])
    circ.x(3)
    circ.append(dscrgate, [qr[0],qr[1],qr[2],qr[3],qr[4]])
    print(circ)
    # dec_circ = circ.decompose()
    # print(dec_circ)
    
    scrOp = Operator(scrgate)
    dscrOp = Operator(dscrgate)
    # print(scrOp, dscrOp)
    print(bdmscore, dbdmscore)
    print(scrOp.is_unitary(), dscrOp.is_unitary()) 
 


